view 폴더에 login_success.ts 같은 파일 모아놓기.
main 폴더에 login.ts같은 파일 모아놓기
dao -> interface로 강제하기

export interface ILoginRequest{ // logincontext에 만들기
	req_id : string;
	req_pw : string
}

<identifier.ts>
apply(){
	let req_id = context.req.req_id; 이런식으로..
}

<login.ts>
const req = {
req_id:"test"
}

const userDao = new UserDao();
const userDao = new UserDao_db();
let userContext = new LoginContext(req, user)
// let userContext = new LoginContext(req, DaoPro?der.getUserData());


export interface IUserDao{ // dao파일에 만들기

}


컨텍스트가 dao를 가지게하기.
constructor(req: ILoginRequest, userData: IUserDao){
	
}
identifier.ts에서..
context.userDao 이런식으로 사용


serve.config.json




register정책
- id중복체크(다른 회사면 중복 가능)
- 회사별 user_limit_count 체크 (몇명까지만 가입된다.)
- password 유효성 체크)숫자 문자 특수문자 조합 7자리이상

policy 클래스는 하나만 존재한다.
<오전>

--------------------------------------------------------------------

<오후>
정책관리 컨테이너 만들기. [decorator]
로그인방법 - id/pw | 문자인증 | ... 
id가 demo 계정
동일한 로직에 대해 .. demo면 안해도 됨..?
로직 사전에 뭘 해야돼
로직 이후에 상황

<데모코드 추가시 상황>
contract_period 
demo용 회사코드는 체크 안해야함.

if(context.~ .company.comcode == "80000"){//무조건 통과 return {status:true, message:success}}

demo company 정책 만들어서 넣으면...

이처럼 데모코드 추가시 
앞에 실행될 로직 . 뒤에 실행될 로직. 
동적으로 주입할 수 있는 개념들 존재.
url 필터 - mvc의 라우트 url 맵핑
Route() - 


----------------------------------------------------------------------------------

Policy interface{
async apply()}

login.ts에서..
await apply(loginContext)

<루프 -> promise>
순차적으로 하는거를 promise chain 이용
indentifier -> contract_period -> account

const loginProcess = Promise.resolve()

loginProcess.then(contract_period)

.then(identifier)
.then(...
.catch(login_fail)

프로미스 - 결국은 내가 원할때